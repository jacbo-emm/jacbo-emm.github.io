<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/post/0.html"/>
      <url>/post/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Flink编程模型"><a href="#Flink编程模型" class="headerlink" title="Flink编程模型"></a>Flink编程模型</h2><h3 id="分层API"><a href="#分层API" class="headerlink" title="分层API"></a>分层API</h3><p>1、ProcessFunction</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProcessFunction</span> <span class="keyword">extends</span> <span class="title class_">ProcessFunction</span>&lt;String, String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ValueState&lt;Integer&gt; count = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ValueStateDescriptor&lt;Integer&gt; descriptor = <span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;&gt;(<span class="string">&quot;count&quot;</span>, Integer.class);</span><br><span class="line">        count = getRuntimeContext().getState(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(String value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">currentCount</span> <span class="operator">=</span> count.value();</span><br><span class="line">        <span class="keyword">if</span> (currentCount == <span class="literal">null</span>) &#123;</span><br><span class="line">            currentCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currentCount += <span class="number">1</span>;</span><br><span class="line">        count.update(currentCount);</span><br><span class="line">        out.collect(<span class="string">&quot;Input: &quot;</span> + value + <span class="string">&quot;, Count: &quot;</span> + currentCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、DataStream API</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStream&lt;String&gt; input = env.addSource(<span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer</span>&lt;&gt;(<span class="string">&quot;input-topic&quot;</span>, <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(), properties));</span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; result = input.flatMap(<span class="keyword">new</span> <span class="title class_">FlatMapFunction</span>&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : value.split(<span class="string">&quot;\\s&quot;</span>)) &#123;</span><br><span class="line">            out.collect(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(word, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).keyBy(<span class="number">0</span>).sum(<span class="number">1</span>);</span><br><span class="line">result.print();</span><br></pre></td></tr></table></figure><p>3、SQL &amp; Table API</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> TableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register a table named &quot;input&quot;</span></span><br><span class="line">DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; input = env.fromElements(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>));</span><br><span class="line">tableEnv.registerDataStream(<span class="string">&quot;input&quot;</span>, input, $(<span class="string">&quot;word&quot;</span>), $(<span class="string">&quot;frequency&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// execute a SQL query</span></span><br><span class="line"><span class="type">Table</span> <span class="variable">result</span> <span class="operator">=</span> tableEnv.sqlQuery(<span class="string">&quot;SELECT word, SUM(frequency) as frequency FROM input GROUP BY word&quot;</span>);</span><br><span class="line">DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultStream = tableEnv.toRetractStream(result, Row.class);</span><br><span class="line">resultStream.print();</span><br></pre></td></tr></table></figure><h4 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Source</span></span><br><span class="line">Datastream&lt;String&gt; lines = env.addsource <span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer</span>&lt;&gt;(...))</span><br><span class="line">Datastream&lt;Event&gt; events = lines.map((line) -&gt; parse(line));</span><br><span class="line"><span class="comment">// Transformation</span></span><br><span class="line">Datastream&lt;Statistics&gt; stats = events</span><br><span class="line">    .keyBy(event -&gt; event.id)</span><br><span class="line">    .timeWindow(Time.seconds(<span class="number">10</span>))</span><br><span class="line">    .apply(<span class="keyword">new</span> <span class="title class_">MywindowAggregationFunction</span>());</span><br><span class="line"><span class="comment">// Sink</span></span><br><span class="line">stats.addsink(<span class="keyword">new</span> <span class="title class_">MySink</span>(...));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flink任务调度</title>
      <link href="/post/beed7eae.html"/>
      <url>/post/beed7eae.html</url>
      
        <content type="html"><![CDATA[<h3 id="Flink任务调度"><a href="#Flink任务调度" class="headerlink" title="Flink任务调度"></a>Flink任务调度</h3><p>​<strong>JobManagers</strong> ：JobManager有时也叫Masters，主要是协调分布式运行。他们调度任务，协调checkpoint，协调失败任务的恢复等等一个Flink集群中至少有一台JobManager节点。高可用性的集群中将会有多台JobManager节点，其中有一台是leader节点，其他的是备节点(standby)。</p><p>​**TaskManagers:**TaskManagers有时也叫Workers，TaskManager主要是执行data flow中的任务(tasks)，缓存数据以及进行数据流的交换。TaskManager在同一个JVM中以多线程的方式执行任务TaskManager提供了一定数量的处理插槽（processing slots），用于控制可以并行执行的任务数。每一个集群中至少有一个TaskManager。一个TaskManager可以同时执行多个任务（tasks）</p><ul><li>这些任务可以是同一个算子的子任务（数据并行）</li><li>这些任务可以是来自不同算子（任务并行）</li><li>这些任务可以是另一个不同应用程序（作业并行）</li></ul><p>Flink 是一个分布式流处理框架，任务调度是其核心功能之一。Flink 采用基于事件驱动的调度方式，它可以根据需要在集群中部署和调度一系列可以并发执行的任务，提供了以下几种类型的任务：</p><ol><li>Job：Flink 执行的最基本单元，可用于执行离线批处理、流处理和机器学习等任务。</li><li>Task：一个 Job 由一个或多个 Task 组成，Task 依赖于操作符（Operator），每个操作符负责处理数据流中的一个子任务。</li><li>Subtask：Task 在运行时会被分割成若干个 Subtask 执行，Subtask 维护自己所处理的数据分区，是 Flink 数据并行执行的最小单元。</li></ol><p>任务调度主要包含以下两个方面：</p><ol><li>作业管理：Flink 支持以 JobManager 的形式对作业进行管理，JobManager 负责接收和解析作业提交请求，并将作业拆分成多个 Task，最后将 Task 分配给 TaskManager 执行。</li><li>资源管理：Flink 支持以 ResourceManager 的形式对集群资源进行管理，ResourceManager 负责分配和管理 TaskManager 所需的计算和内存资源。</li></ol><p>具体来说，Flink 的任务调度流程大概如下：</p><ol><li>用户通过客户端向 JobManager 提交作业。</li><li>JobManager 对作业进行解析和划分，并将作业提交给 ResourceManager。</li><li>ResourceManager 根据集群资源的使用情况，为 TaskManager 分配所需的计算和内存资源。</li><li>TaskManager 根据分配的资源启动 Subtask 执行，Subtask 会依次处理数据分区并输出结果。</li><li>JobManager 监控执行状态，如果作业失败或异常终止，则会根据用户定义的策略进行自动重启或手动恢复。</li></ol><p>总的来说，Flink 的任务调度机制是非常健壮和强大的，可以快速、高效地处理各种类型的数据流和处理任务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Flink学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
